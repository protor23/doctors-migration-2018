---
title: Healthcare Workers' Interregional Migration
subtitle: "PSY6422 Assessment"
author: "Ruri Proto"
date: "31/05/2021"
output: 
  html_document:
    theme: united
---

## **Research Questions**

* To which geographical regions do healthcare workers migrate?

* From which geographical regions do healthcare workers emigrate?

* Are there any preferences, such that healthcare workers from a given region are more likely to emigrate to another specific region?

## **Data Origin**

I retrieved data from the [OECD website](https://stats.oecd.org/Index.aspx?DataSetCode=HEALTH_WFMI), where I downloaded migration information from all OECD countries in 2018. This refers to the number of healthcare workers (doctors and nurses) who are registered or in the process to gain registration to practise in a country other than the one in which they have obtained their medical education qualifications. 

I subsequently retrieved a dataset linking countries with grographical subregions from [github](https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes/blob/master/all/all.csv). 

```{r eval = TRUE, results = "hide", message = FALSE}
library(readr)
library(here)

wf_mig = read_csv(here("data-raw/workforce-migration.csv")) #migration data
sub_reg = read_csv(here("data-raw/subregions.csv")) #subregions data
```
```{r eval = TRUE}
head(wf_mig)
head(sub_reg)
```

## **Data Processing**

Data processing was long and tedious, hence difficult to present here. However, interested readers should check the relevant [script](https://github.com/protor23/healthcare-workers-migration/blob/main/scripts/01_data-processing.R), but examples are provided here.

It included:

* eliminating irrelevant rows and columns and renaming columns
```{r eval = TRUE, results = "hide", message = FALSE}
library(dplyr)

wf_mig = wf_mig[, -3] #eliminate year column
colnames(wf_mig) = c("to", "from", "number") #rename columns

wf_mig = wf_mig %>%
  filter(to != from) %>%
  filter(number != 0) #remove domestic migration cases and cases with 0 migrants
```

* (unfortunately) hardcoding

I discovered wf_mig and sub_reg had different names for the same countries, or some countries in wf_mig were not featured in sub_reg. There few instances of these issues, so I replaced the missing data easily after extensive geopolitical googling!

```{r echo = FALSE, results = "hide", message = FALSE}
source(here("scripts/01_data-processing.R"))
```

```{r message = FALSE}
for(i in 1:length(missing_countries)) { #for every missing country
  for (j in 1:length(unique(sub_reg)$country)) #check all unique countries in sub_reg
    if(str_detect(unique(sub_reg)$country[j], missing_countries[i])) { #find similarities
      print(c(unique(sub_reg)$country[j], missing_countries[i])) #print similarities
    }
}
```
* joining data sets

I allocated subregions to both countries of origin and destination countries.

```{r eval = FALSE}
data = left_join(wf_mig, sub_reg, by = c("to" = "country_join"))

data = rename(data, subregion_to =  subregion)

data = left_join(data, sub_reg, by = c("from" = "country_join"))

data = rename(data, subregion_from = subregion
```

The final dataset had no missing values:

```{r eval = TRUE}
head(data)

sapply(data, 
       function(x) sum(is.na(x))
)
```

## **Intermediate data transformations**

The visualization I have planned requires two objects, a matrix showing the number of migrants for all combinations of subregions, and a data frame showing assigning plotting details (e.g., colours) to each individual subregion. The code for this work is presented [here](https://github.com/protor23/healthcare-workers-migration/blob/main/scripts/02_visualization-matrices.R). 



At the end, the two objects looked like this:
```{r echo = FALSE, results = "hide", message = FALSE}
source(here("scripts/02_visualization-matrices.R"))
```

```{r eval = TRUE}
head(flow_matrix)
head(subregion_details)
```

## **Data visualization**

Note I have adjusted text parameters to look good here.
```{r eval = TRUE}
library(circlize)

circos.clear() #reset circular layout parameters

par(mar = rep(0 , 4)) #set margins to 0 
circos.par(cell.padding = c(0, 0, 0, 0), 
           track.margin = c(0, 0.1), 
           start.degree = 90, #start plotting at 12 o'clock
           gap.degree = 2, #gap between circle sectors
           points.overflow.warning = FALSE, 
           canvas.xlim = c(-1.5, 1.5), 
           canvas.ylim = c(-1.5, 1.5) 
)

circos.initialize(factors = subregion_details$subregion, #allocate sectors on circle to subregions
                  xlim = cbind(subregion_details$xmin, 
                               subregion_details$total) #set limits of the x axis for each sector between 0 and total flow
)

#### Plot sectors ####

circos.trackPlotRegion(ylim = c(0, 1), #y-axis limits for each sector
                       factors = subregion_details$subregion, 
                       track.height = 0.2, 
                       panel.fun = function(x, y) { #for each new cell (i.e., intersection between sector and track)
                         name = get.cell.meta.data("sector.index") #retrieve cell meta data
                         i = get.cell.meta.data("sector.numeric.index")
                         xlim = get.cell.meta.data("xlim")
                         ylim = get.cell.meta.data("ylim")
                         
                         #plot subregion names
                         circos.text(x = mean(xlim), #position text at middle of sector
                                     y = 2.5, #distance from circle
                                     labels = name, #name of subregion
                                     facing = "clockwise", 
                                     niceFacing = TRUE,
                                     cex = 0.5 #scale text
                         )
                         
                         #plot a sector for each subregion
                         circos.rect(xleft = xlim[1], 
                                     ybottom = ylim[1], 
                                     xright = xlim[2], 
                                     ytop = ylim[2], 
                                     col = subregion_details$rcol[i], #use less transparent colours
                                     border = subregion_details$rcol[i]
                         )
                         
                         #distinguish between immigrants and emigrants in each subregion
                         circos.rect(xleft = xlim[1], 
                                     ybottom = ylim[1], 
                                     xright = xlim[2] - rowSums(flow_matrix)[i], #i.e., total - emigrants
                                     ytop = ylim[1] + 0.3,
                                     col = "white", 
                                     border = "white"
                         ) 
                         
                         #add a white contour to separate the previous two rectangles
                         circos.rect(xleft = xlim[1], 
                                     ybottom = 0.3, 
                                     xright = xlim[2], 
                                     ytop = 0.32, 
                                     col = "white", 
                                     border = "white"
                         )
                      
                       }
)


#### Plot links ####

#transform flow_matrix into its long form and sort it 
flow_matrix_long = melt(flow_matrix,
                        value.name = "number"
)

colnames(flow_matrix_long) = c("subregion_from",
                               "subregion_to",
                               "number") #rename columns for consistency

#sort descendently according to the number of migrants
flow_matrix_long = flow_matrix_long %>%
  arrange(desc(number)) 

#keep only the largest flows to increase readability
flow_matrix_long = subset(flow_matrix_long, 
                          number > quantile(number, 0.75)
)


subregion_details$sum1 <- colSums(flow_matrix) #number of immigrants
subregion_details$sum2 <- numeric(nrow(subregion_details)) #number of subregions

#not yet clear why this is needed, but it prevents links from being plotted outside of range
circos.par(track.margin = c(0,0)) 

#plot links for each combination of regions
for(k in 1:nrow(flow_matrix_long)){ #for each row in the flow matrix
  i = match(flow_matrix_long$subregion_from[k],
            subregion_details$subregion) #get plotting details for subregion of origin
  j = match(flow_matrix_long$subregion_to[k],
            subregion_details$subregion) #get plotting details for destination subregion
  
  circos.link(sector.index1 = subregion_details$subregion[i], #need to identify indices to identify 
              point1 = c(subregion_details$sum1[i], 
                         subregion_details$sum1[i] + abs(flow_matrix[i, j])), #starting point of link
              
              sector.index2 = subregion_details$subregion[j], 
              point2=c(subregion_details$sum2[j], 
                       subregion_details$sum2[j] + abs(flow_matrix[i, j])), #endpoint of link
              
              col = subregion_details$lcol[i], #use the more transparent collor to increase visibility
              border = subregion_details$lcol[i]
  )
  
  #update sum1 and sum2 for use when plotting the next link
  subregion_details$sum1[i] = subregion_details$sum1[i] + abs(flow_matrix[i, j]) 
  subregion_details$sum2[j] = subregion_details$sum2[j] + abs(flow_matrix[i, j])
}
```


