---
title: Healthcare Workers' Interregional Migration
subtitle: "PSY6422 Assessment"
author: "Ruri Proto"
date: "31/05/2021"
output: 
  html_document: 
  toc: TRUE
---

## **Research Questions**

* To which geographical regions do healthcare workers migrate?

* From which geographical regions do healthcare workers emigrate?

* Are there any preferences, such that healthcare workers from a given region are more likely to emigrate to another specific region?

## **Data Origin**

I retrieved data from the [OECD website](https://stats.oecd.org/Index.aspx?DataSetCode=HEALTH_WFMI), where I downloaded migration information from all OECD countries in 2018. This refers to the number of healthcare workers (doctors and nurses) who are registered or in the process to gain registration to practise in a country other than the one in which they have obtained their medical education qualifications. 

I subsequently retrieved a dataset linking countries with grographical subregions from [github](https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes/blob/master/all/all.csv). I chose subregions because they are narrower than regions, but broader than individual countries, which will allow me to plot them on a circle whilst maintaining readability. 

I started by loading the data in two data frames:

```{r eval = TRUE, results = "hide", message = FALSE}
library(readr)
library(here)

wf_mig = read_csv(here("data-raw/workforce-migration.csv")) #migration data
sub_reg = read_csv(here("data-raw/subregions.csv")) #subregions data
```

The data frames look like this:
```{r eval = TRUE}
head(wf_mig)
head(sub_reg)
```

## **Data Processing**

Data processing was long and tedious, so only the highlights are presented here. Interested readers should check the relevant [script](https://github.com/protor23/healthcare-workers-migration/blob/main/scripts/01_data-processing.R) for the detailed data processing steps taken.  

### **Removing unnecessary data**

I removed flows between identical countries, cases where the migration flow was 0, and unnecessary columns such as the year of migration (since it is only 2018 data) and information about regions in sub_reg (since I was only interested in subregions). 

```{r eval = TRUE, results = "hide", message = FALSE}
library(dplyr)

wf_mig = wf_mig[, -3] #eliminate year column
colnames(wf_mig) = c("to", "from", "number") #rename columns

wf_mig = wf_mig %>%
  filter(to != from) %>%
  filter(number != 0) #remove domestic migration cases and cases with 0 migrants

sub_reg = sub_reg[ ,c("name", "sub-region")] #select relevant columns
colnames(sub_reg) = c('country', "subregion") #rename columns
```

### **Filling in missing data**

I discovered wf_mig and sub_reg had different names for the same countries, or some countries in wf_mig were not featured in sub_reg. There few instances of these issues, so I replaced the missing data easily after extensive geopolitical googling! 

I stated by looking for countries found in sub_reg and not in wf_mig:

```{r eval = TRUE, warnings = FALSE}
data.frame(country = unique(c(setdiff(wf_mig$to, sub_reg$country), 
                                     setdiff(wf_mig$from, sub_reg$country)
                              )
          )
)
```

I susbequently included keywords of these countries (e.g., Moldova for Republic of Moldova) and looked for these in sub_reg to understand why they were not present there:

```{r echo = FALSE, results = "hide", message = FALSE}
source(here("scripts/01_data-processing.R"))
```

```{r message = FALSE}
for(i in 1:length(missing_countries)) { #for every missing country
  for (j in 1:length(unique(sub_reg)$country)) #check all unique countries in sub_reg
    if(str_detect(unique(sub_reg)$country[j], missing_countries[i])) { #find similarities
      print(c(unique(sub_reg)$country[j], missing_countries[i])) #print similarities
    }
}
```

Most of these similarities made sense, so I manually added  these country names to the sub_reg data set to match the wf_mig names.

### **Joining data frames**

I then allocated subregions to each country by joining wf_mig and sub_reg by country name and provided helpful names to distinguish between origin and destination subregions. I then discovered some countries were missing from sub_reg, so I added subregions for them manually to the final data set. More geopolitical googling!

```{r eval = FALSE}
data = left_join(wf_mig, sub_reg, by = c("to" = "country_join"))

data = rename(data, subregion_to =  subregion)

data = left_join(data, sub_reg, by = c("from" = "country_join"))

data = rename(data, subregion_from = subregion)
```

### **Evaluating the final dataset**

The final dataset had no missing values and made sense. 

```{r include = FALSE}
source(here("scripts/01_data-processing.R"))
```

```{r eval = TRUE}
sapply(data, 
       function(x) sum(is.na(x))
)

head(data)
```

## **Intermediate data transformations**

The visualization I planned requires two objects. 

* flow_matrix  - the number of migrants for all combinations of subregions 

* subregion_details - a data frame showing plotting details (e.g., colours) for each subregion. 

The code for this work is [here](https://github.com/protor23/healthcare-workers-migration/blob/main/scripts/02_visualization-matrices.R).

### **The flow matrix** 

I started by computing the total number of migrants per subregion of origin and destination, irrespective of country:

```{r eval = TRUE}
subregions = data[ , 3:5] #retrieve subregions and number of migrants from dataset

subregions = subregions %>%
  group_by(subregion_from, subregion_to) %>%
  summarize(no = sum(number)) #number of total migrants per subregion

head(subregions)
```
I subsequently created a flow matrix with all subregions as rows and columns which contained only 0s. I treated rows as origin subregions and columns as destination subregions, and I subsequently updated its values with the ones in the subregions dataframe (which I transformed into its wide format for convencience).

```{r include = FALSE}
#find all subregions in the dataset
factors = unique(c(unique(data$subregion_to), 
                   unique(data$subregion_from)
                   )
)

library(reshape2)

subregions = dcast(subregions,
                   subregion_from ~ subregion_to, #origin subregions as rows
                   value.var = "no"
) #convert into wide format

#set rownames to subregion_from to facilitate indexing
rownames(subregions) = subregions$subregion_from 

#initialise flow matrix as a quadratic matrix with all values of 0 
x = rep(0, length(factors)^2)
row_n = factors #row names for matrix
col_n = factors #column names for matrix

flow_matrix = matrix(x, 
                     nrow = length(factors), 
                     byrow = TRUE,
                     dimnames = list(row_n, col_n)
) #create matrix
```

```{r eval = TRUE, results = "hide"}
#find all subregions in the dataset
factors = unique(c(unique(data$subregion_to), 
                   unique(data$subregion_from)
                   )
)

for(i in factors) { #take each unique subregion
  for(j in factors) { #combine it with all subregions
    flow_matrix[i, j] = ifelse( #for each combination
      (flow_matrix[i, j] != subregions[i, j] && #if subregions value is different from flow_matrix value
         !(is.na(subregions[i, j]))),  #providing subregions value is not missing
      subregions[i, j], #replace value in flow_matrix with subregions value 
      0 #otherwise keep 0 in flow_matrix
    )
  }
}
```

At the end, the flow matrix looked like this:
```{r echo = FALSE, results = "hide", message = FALSE}
source(here("scripts/02_visualization-matrices.R"))
```

```{r eval = TRUE}
head(flow_matrix)
```

### **The subregion details data frame** 

This data frame needs to include colours for circle sectors, circle links, and the total flow of migrants (immigrants + emigrants) in each country. Code for this section has been largely adapted from Sanders et al. (2014). 

I googled 16 rgb codes and selected colours to enhance contrast, as follows:

```{r eval = FALSE}
subregion_details$rgb = c("255,0,0", "0,255,0", "0,0,255", 
                          "255,255,0", "0,255,255", "255,0,255",
                          "128,128,128", "128,0,0", "128,128,0", 
                          "0,128,0", "128,0,128", "0,128,128",
                          "0,0,128", "152,251,152", "30,144,255", 
                          "138,43,226")
```

I then stored two versions of these colours, one of which had increased transparency. To accomplish this, I had to split rgb codes into individual variables:

```{r eval = FALSE}
#Split rgb codes into 3 variables - adapted from Sander et al. (2014)
n = nrow(subregion_details)
subregion_details = cbind(subregion_details, #split codes and treat them as numbers
                          matrix(as.numeric(unlist(strsplit(subregion_details$rgb, split = ","))), 
                                 nrow = n, byrow = TRUE 
                                 ) #arrange them in n columns in a matrix
)

subregion_details = subregion_details %>%
  rename( #rename columns according to the colour index
    r = '1',
    g = '2',
    b = '3',
  )

#add two similar colours varying in transparency per subregion
subregion_details$rcol = rgb(subregion_details$r, 
                             subregion_details$g, 
                             subregion_details$b, 
                             max = 255
)

subregion_details$lcol = rgb(subregion_details$r, 
                             subregion_details$g, 
                             subregion_details$b, 
                             alpha=200, #transparency index
                             max = 255
)

```

I finally included the total number of migrants by adding the number of immigrants and emigrants:

```{r eval = FALSE}
#Compute number of emigrants per region
df_from = data %>%
  group_by(subregion_from) %>%
  summarize(sum(number))

#Compute number of immigrants per region
df_to = data %>%
  group_by(subregion_to) %>%
  summarize(sum(number))

#Create subregion_details data frame with info about migrants and emigrants
subregion_details = left_join(df_from, 
                              df_to, 
                              by = c("subregion_from" = "subregion_to")
) #join data frames

colnames(subregion_details) = c("subregion", "outer", "inner") #rename columns

subregion_details$total = rowSums(subregion_details[ ,c("outer", "inner")], 
                                 na.rm = TRUE) #add total migrants to datframe
```

I also added an xmin column with all values of 0, as this will help position circle links when visualising the data. At the end, the subregion_details data frame looked like this:
```{r echo=FALSE, message=FALSE, results="hide"}
source(here("scripts/02_visualization-matrices.R"))
```

```{r eval = TRUE}
head(subregion_details)
```

## **Data visualization**

The code for the visualization is quite complex. Essentially, it involves drawing a track on a circle, which is subsequently split into sectors, one for each subregion, depending on their relative amounts of total migrants. Subsequently, links (or ribbons) are drawn from each subregion indicating the flow of migrants, wherein the thickness or the ribbon corresponds to the relative sizes of the number of migrants. 

One of the greatest mysteries of my life remains the reason as to why this plot looks terrible on github pages or in R, but great as a pdf. I have attached the pdf here to demonstrate this, but rest assured the code works, and you can find it [here](https://github.com/protor23/healthcare-workers-migration/blob/main/scripts/03_visualize-data.R), as well as explained quite nicely below.


I started by setting some plotting parameters related to the size of the circle, padding, sector gaps, and the starting plotting point. Please note these are different from the code in the script, as I have changed them to allow readability on github specifically. 

```{r eval = TRUE, messages = FALSE}
suppressPackageStartupMessages(library(circlize))

circos.clear() #reset circular layout parameters

par(mar = rep(0 , 4)) #set margins to 0 
circos.par(cell.padding = c(0, 0, 0, 0), 
           track.margin = c(0, 0.1), 
           start.degree = 90, #start plotting at 12 o'clock
           gap.degree = 2, #gap between circle sectors
           points.overflow.warning = FALSE, 
           canvas.xlim = c(-1.5, 1.5), 
           canvas.ylim = c(-1.5, 1.5) 
)
```

I then initialized the layout to allocate subregions into sectors whose sizes are defined by 0 (xmin) and the total flow of migrants for that subregion. This approach ensures the relative size of sectors matches the relative migration flows for each subregion. 

The next step involved creating a plotting region to which I added graphics. The `panel.fun()` function has the immense advantage that it allows one to plot graphics immediately after a cell has been created, removing the need for consistent indexing. 

I started by plotting subregion names using `circos.text()`. A little disclaimer is that I still have not found a way to adjust the position of text for each subsector, hence all the subregion names are quite far from the circle to prevent overlaps between the plot and text. 

I next plotted a first track (i.e., the circular layer split into different sectors), with the non-transparent colours corresponding to each subregion, using `circos.rect()`. I plotted a second track, this time only included a coloured portion of the sector that corresponds to the number of immigrants specifically, rather than all migrants. 

This initial work resulted in a preliminary plot:

```{r eval = TRUE}
circos.initialize(factors = subregion_details$subregion, #allocate sectors on circle to subregions
                  xlim = cbind(subregion_details$xmin, 
                               subregion_details$total) 
                  #set limits of the x axis for each sector between 0 and total flow
)

circos.trackPlotRegion(ylim = c(0, 1), #y-axis limits for each sector
                       factors = subregion_details$subregion, 
                       track.height = 0.2, 
                       panel.fun = function(x, y) { #for each new cell (i.e., intersection between sector and track)
                         name = get.cell.meta.data("sector.index") #retrieve cell meta data
                         i = get.cell.meta.data("sector.numeric.index")
                         xlim = get.cell.meta.data("xlim")
                         ylim = get.cell.meta.data("ylim")
                         
                         #plot subregion names
                         circos.text(x = mean(xlim), #position text at middle of sector
                                     y = 2.5, #distance from circle
                                     labels = name, #name of subregion
                                     facing = "clockwise", 
                                     niceFacing = TRUE, #adjust positions to make it readable by humans
                                     cex = 0.5 #scale text
                         )
                         
                         #plot a sector for each subregion
                         circos.rect(xleft = xlim[1], 
                                     ybottom = ylim[1], 
                                     xright = xlim[2], 
                                     ytop = ylim[2], 
                                     col = subregion_details$rcol[i], #use less transparent colours
                                     border = subregion_details$rcol[i]
                         )
                         
                         #distinguish between immigrants and emigrants in each subregion
                         circos.rect(xleft = xlim[1], 
                                     ybottom = ylim[1], 
                                     xright = xlim[2] - rowSums(flow_matrix)[i], #i.e., total - emigrants
                                     ytop = ylim[1] + 0.3,
                                     col = "white", 
                                     border = "white"
                         ) 
                         
                         #add a white contour to separate the previous two rectangles
                         circos.rect(xleft = xlim[1], 
                                     ybottom = 0.3, 
                                     xright = xlim[2], 
                                     ytop = 0.32, 
                                     col = "white", 
                                     border = "white"
                         )
                      
                       }
)
```

Next, I included ribbons to link origin subregions to destination subregions, in order to show migration patterns across regions. This required some further data processing to transform the flow_matrix into its long format and add parameters to guide the position of links, `sums1` and `sums2`. This is explained in depth in the full script. 

```{r eval = FALSE}
#plot links for each combination of regions
for(k in 1:nrow(flow_matrix_long)){ #for each row in the flow matrix
  i = match(flow_matrix_long$subregion_from[k],
            subregion_details$subregion) #get plotting details for subregion of origin
  j = match(flow_matrix_long$subregion_to[k],
            subregion_details$subregion) #get plotting details for destination subregion
  
  circos.link(sector.index1 = subregion_details$subregion[i], #need to identify indices
              point1 = c(subregion_details$sum1[i], 
                         subregion_details$sum1[i] + abs(flow_matrix[i, j])), #starting point of link
              
              sector.index2 = subregion_details$subregion[j], 
              point2=c(subregion_details$sum2[j], 
                       subregion_details$sum2[j] + abs(flow_matrix[i, j])), #endpoint of link
              
              border = subregion_details$lcol[i],
              col = subregion_details$lcol[i], #use the more transparent colour to increase visibility
  )
  
  #update sum1 and sum2 for use when plotting the next link
  subregion_details$sum1[i] = subregion_details$sum1[i] + abs(flow_matrix[i, j]) 
  subregion_details$sum2[j] = subregion_details$sum2[j] + abs(flow_matrix[i, j])
}
```

As a result, I produced this plot - which is linked here as a pdf because it looks horrendous when I run the code on github and in R.

![](figs/01_migration-flow.png)

As we can see, Western Europe has by far the most migrants, followed by Norther Europe and Eastern Europe. However, whilst Western and Northern Europe have relatively low proportions of emigrants and high of immigrants, this is completely the opposite in Eastern Europe. 

Also, notice that Northern America and Western Europe are the most common immigration destinations for almost all subregions. Similarly, notice how most individuals in Latin America and the Caribbean emigrate in the same region. 

## **Summary**

Through this project, I have learnt that... working with geographical datasets without proper unique keys is a nightmare when it comes to joining data sets. That is my highlight.

On a serious note, I love circular plots - they are not necessarily immediately intuitive (which might cause them to be dismissed at times), but once the eye gets trained into how to interpret them, they become useful because one can pack a lot of information into one single plot. However, the danger with this is that one must be careful not to overcomplicate or overcrowd the plot with meaningless details. Fine balance to strike, but I am hoping I can see this type of plot used in behavioural research as well. 

If I had more time to spend on this project, I would attempt to fix the issue that causes some ribbons to go beyond the borders for emigrants - yes, Northern Africa, I'm looking at you! I am still not sure what the reason for this is, but the circlize package still receives updates, so I can only keep an eye on it. 

Additionally, I would extend this project beyond this plot to understand why healthcare workers migrate to specific subregions - Is it better pay? Is it the chance to work in specific areas of medicine? So much to know. 

It would aso be interesting to evaluate how migration flow patterns change over time, and perhaps visualise this with an interactive plot. Next time, maybe?





